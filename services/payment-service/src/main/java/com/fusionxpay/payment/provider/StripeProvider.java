package com.fusionxpay.payment.provider;

import com.fusionxpay.payment.dto.PaymentRequest;
import com.fusionxpay.payment.dto.PaymentResponse;
import com.fusionxpay.payment.service.IdempotencyService;
import com.fusionxpay.common.model.PaymentStatus;
import com.stripe.Stripe;
import com.stripe.exception.SignatureVerificationException;
import com.stripe.exception.StripeException;
import com.stripe.model.Event;
import com.stripe.model.PaymentIntent;
import com.stripe.model.checkout.Session;
import com.stripe.net.Webhook;
import com.stripe.param.checkout.SessionCreateParams;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Stripe payment processor implementation
 */
@Slf4j
@Service
public class StripeProvider implements PaymentProvider {

    @Value("${payment.providers.stripe.secret-key}")
    private String apiKey;

    @Value("${payment.providers.stripe.webhook-secret}")
    private String webhookSecret;

    @Value("${payment.providers.stripe.api-base-url:}")
    private String apiBaseUrl;
    
    // Redis configuration for idempotency
    private final RedisTemplate<String, String> redisTemplate;
    private final IdempotencyService idempotencyService;
    private static final String STRIPE_WEBHOOK_EVENT_PREFIX = "stripe:webhook:event:";
    private static final Duration EVENT_TTL = Duration.ofDays(7); // Store events for 7 days
    
    public StripeProvider(RedisTemplate<String, String> redisTemplate, IdempotencyService idempotencyService) {
        this.redisTemplate = redisTemplate;
        this.idempotencyService = idempotencyService;
    }

    @PostConstruct
    public void init() {
        Stripe.apiKey = apiKey;
        if (apiBaseUrl != null && !apiBaseUrl.isBlank()) {
            Stripe.overrideApiBase(apiBaseUrl);
            log.info("Stripe API base URL overridden to {}", apiBaseUrl);
        } else {
            Stripe.overrideApiBase(Stripe.LIVE_API_BASE);
        }
        log.info("Stripe payment provider initialized");
    }

    @Override
    public PaymentResponse processPayment(PaymentRequest paymentRequest) {
        log.info("Processing payment with Stripe: {}", paymentRequest);

        try {
            // Create metadata for tracking
            Map<String, String> metadata = new HashMap<>();
            metadata.put("orderId", paymentRequest.getOrderId().toString());
            metadata.put("merchantReference", paymentRequest.getMerchantReference());

            // Create checkout session
            SessionCreateParams params = SessionCreateParams.builder()
                    .setMode(SessionCreateParams.Mode.PAYMENT)
                    .setSuccessUrl(paymentRequest.getReturnUrl())
                    .setCancelUrl(paymentRequest.getCancelUrl())
                    .addLineItem(createLineItem(paymentRequest))
                    .setPaymentIntentData(
                            SessionCreateParams.PaymentIntentData.builder()
                                    .putAllMetadata(metadata)
                                    .build()
                    )
                    .putAllMetadata(metadata)
                    .setClientReferenceId(paymentRequest.getOrderId().toString())
                    .build();

            Session session = Session.create(params);
            
            // Use session.getId() as Stripe's transaction reference
            // Our system's transaction ID will be generated by the database
            return PaymentResponse.builder()
                    .status(PaymentStatus.PROCESSING)
                    .orderId(paymentRequest.getOrderId())
                    .paymentChannel(getProviderName())
                    .redirectUrl(session.getUrl())
                    .providerTransactionId(session.getId()) // Store Stripe's session ID
                    .build();

        } catch (StripeException e) {
            log.error("Error processing Stripe payment: {}", e.getMessage(), e);
            return handlePaymentError(paymentRequest, e);
        }
    }

    private SessionCreateParams.LineItem createLineItem(PaymentRequest paymentRequest) {
        // Get amount in smallest currency unit (e.g. cents)
        long amountInSmallestUnit = paymentRequest.getAmount().multiply(new BigDecimal(100)).longValue();
        
        return SessionCreateParams.LineItem.builder()
                .setPriceData(
                        SessionCreateParams.LineItem.PriceData.builder()
                                .setCurrency(paymentRequest.getCurrency().toLowerCase())
                                .setUnitAmount(amountInSmallestUnit)
                                .setProductData(
                                        SessionCreateParams.LineItem.PriceData.ProductData.builder()
                                                .setName("Order #" + paymentRequest.getOrderId())
                                                .setDescription(paymentRequest.getDescription())
                                                .build()
                                )
                                .build()
                )
                .setQuantity(1L)
                .build();
    }

    @Override
    public PaymentResponse processCallback(String payload, String signature) {
        try {
            Event event = Webhook.constructEvent(payload, signature, webhookSecret);
            String eventId = event.getId();
            String eventType = event.getType();
            log.info("Processing Stripe webhook event: {}, id: {}", eventType, eventId);
            
            // Only process payment status events (success or failure)
            if (!isPaymentStatusEvent(eventType)) {
                log.info("Ignoring non-payment status event: {}", eventType);
                return null;
            }
            
            // Extract orderId based on event type
            String orderId;
            try {
                orderId = extractOrderIdFromEvent(event);
                if (orderId == null) {
                    log.warn("Could not extract orderId from event {}", eventId);
                    return createErrorResponse("Could not extract orderId from event");
                }
            } catch (Exception e) {
                log.error("Error extracting orderId from event: {}", e.getMessage(), e);
                return createErrorResponse("Error extracting orderId: " + e.getMessage());
            }
            
            // Create an order-based Redis key for idempotency
            String orderKey = STRIPE_WEBHOOK_EVENT_PREFIX + "order:" + orderId;
            
            // Check if this order's payment status has already been processed
            String processingState = idempotencyService.getProcessingState(orderKey);
            
            if (processingState != null) {
                if ("completed".equals(processingState)) {
                    log.info("Payment status for order {} already processed", orderId);
                    return PaymentResponse.builder()
                            .status(PaymentStatus.DUPLICATE)
                            .paymentChannel(getProviderName())
                            .providerTransactionId(eventId)
                            .orderId(UUID.fromString(orderId))
                            .build();
                } 
            }
            
            // Try to acquire processing lock for this order's payment status
            boolean lockAcquired = idempotencyService.acquireProcessingLock(orderKey, EVENT_TTL);
            
            if (!lockAcquired) {
                log.warn("Could not acquire processing lock for order {}", orderId);
                return PaymentResponse.builder()
                        .status(PaymentStatus.PROCESSING)
                        .paymentChannel(getProviderName())
                        .providerTransactionId(eventId)
                        .orderId(UUID.fromString(orderId))
                        .build();
            }
            
            // We acquired the lock, process the event
            PaymentResponse response = null;
            try {
                // Process the event based on type
                switch (eventType) {
                    case "payment_intent.succeeded":
                        response = handlePaymentSuccess(event);
                        break;
                    case "payment_intent.payment_failed":
                        response = handlePaymentFailure(event);
                        break;
                    case "checkout.session.completed":
                        response = handleCheckoutSessionCompleted(event);
                        break;
                    case "charge.refunded":
                    case "charge.refund.updated":
                        response = handleRefundEvent(event);
                        break;
                    default:
                        log.info("Unhandled event type: {}", eventType);
                        response = null;
                        break;
                }
                
                // Mark as successfully completed if appropriate
                if (response != null && response.getStatus() != PaymentStatus.FAILED) {
                    idempotencyService.markAsCompleted(orderKey, EVENT_TTL);
                } else if (response == null) {
                    // For events we don't care about, release the lock
                    idempotencyService.releaseLock(orderKey);
                } else {
                    // For failed responses, mark as completed to prevent retries
                    // (we still consider a failed payment as "completed" processing)
                    idempotencyService.markAsCompleted(orderKey, EVENT_TTL);
                }
                
                return response;
            } catch (Exception e) {
                // On any exception, release the lock
                idempotencyService.releaseLock(orderKey);
                throw e;
            }
        } catch (SignatureVerificationException e) {
            log.error("Invalid webhook signature: {}", e.getMessage(), e);
            return createErrorResponse("Invalid webhook signature");
        } catch (Exception e) {
            log.error("Error processing webhook: {}", e.getMessage(), e);
            return createErrorResponse("Webhook processing error: " + e.getMessage());
        }
    }

    // Helper method to determine if this event affects payment status
    private boolean isPaymentStatusEvent(String eventType) {
        return eventType.equals("payment_intent.succeeded") ||
               eventType.equals("payment_intent.payment_failed") ||
               eventType.equals("checkout.session.completed") ||
               eventType.equals("charge.refunded") ||
               eventType.equals("charge.refund.updated");
    }

    // Helper method to extract orderId from different event types
    private String extractOrderIdFromEvent(Event event) {
        String eventType = event.getType();
        if (eventType.equals("payment_intent.succeeded") || eventType.equals("payment_intent.payment_failed")) {
            PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
            return intent.getMetadata().get("orderId");
        } else if (eventType.equals("checkout.session.completed")) {
            Session session = (Session) event.getDataObjectDeserializer().getObject().get();
            if (session.getPaymentIntent() != null) {
                try {
                    PaymentIntent intent = PaymentIntent.retrieve(session.getPaymentIntent());
                    return intent.getMetadata().get("orderId");
                } catch (StripeException e) {
                    log.error("Error retrieving payment intent: {}", e.getMessage(), e);
                    return null;
                }
            } else {
                return session.getClientReferenceId(); // Fallback to client reference ID which should be orderId
            }
        } else if (eventType.equals("charge.refunded") || eventType.equals("charge.refund.updated")) {
            com.stripe.model.Charge charge = (com.stripe.model.Charge) event.getDataObjectDeserializer().getObject().get();
            // Try to get orderId from charge metadata
            if (charge.getMetadata() != null && charge.getMetadata().containsKey("orderId")) {
                return charge.getMetadata().get("orderId");
            }
            // Fallback: try to get from payment intent
            if (charge.getPaymentIntent() != null) {
                try {
                    PaymentIntent intent = PaymentIntent.retrieve(charge.getPaymentIntent());
                    return intent.getMetadata().get("orderId");
                } catch (StripeException e) {
                    log.error("Error retrieving payment intent for refund: {}", e.getMessage(), e);
                    return null;
                }
            }
        }
        return null;
    }

    // Helper method to handle checkout.session.completed events
    private PaymentResponse handleCheckoutSessionCompleted(Event event) {
        Session session = (Session) event.getDataObjectDeserializer().getObject().get();
        if (session.getPaymentIntent() != null) {
            try {
                PaymentIntent intent = PaymentIntent.retrieve(session.getPaymentIntent());
                String orderId = intent.getMetadata().get("orderId");
                
                return PaymentResponse.builder()
                        .status(PaymentStatus.SUCCESS)
                        .orderId(UUID.fromString(orderId))
                        .paymentChannel(getProviderName())
                        // Store Stripe PaymentIntent ID so refunds can be issued later.
                        .providerTransactionId(intent.getId())
                        .build();
            } catch (StripeException e) {
                log.error("Error retrieving payment intent: {}", e.getMessage(), e);
                return createErrorResponse("Error retrieving payment intent: " + e.getMessage());
            }
        } else {
            log.info("Checkout session completed without PaymentIntent");
            return null;
        }
    }

    private PaymentResponse handlePaymentSuccess(Event event) {
        PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
        log.info("Payment succeeded for intent: {}", intent.getId());
        
        String orderId = intent.getMetadata().get("orderId");
        
        return PaymentResponse.builder()
                .status(PaymentStatus.SUCCESS)
                .orderId(UUID.fromString(orderId))
                .paymentChannel(getProviderName())
                .providerTransactionId(intent.getId()) // Store Stripe's payment intent ID
                .build();
    }

    private PaymentResponse handlePaymentFailure(Event event) {
        PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
        log.info("Payment failed for intent: {}", intent.getId());

        String orderId = intent.getMetadata().get("orderId");
        String errorMessage = intent.getLastPaymentError() != null ?
                intent.getLastPaymentError().getMessage() : "Payment failed";

        log.error("Payment failed: {}, order: {}", errorMessage, orderId);

        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .orderId(UUID.fromString(orderId))
                .paymentChannel(getProviderName())
                .providerTransactionId(intent.getId()) // Store Stripe's payment intent ID
                .errorMessage(errorMessage)
                .build();
    }

    /**
     * Handles refund events from Stripe webhooks.
     * Updates the transaction status to REFUNDED when a refund is completed.
     */
    private PaymentResponse handleRefundEvent(Event event) {
        try {
            com.stripe.model.Charge charge = (com.stripe.model.Charge) event.getDataObjectDeserializer().getObject().get();
            String chargeId = charge.getId();
            String refundStatus = charge.getRefunded() != null && charge.getRefunded() ? "refunded" : "partial_refund";

            log.info("Processing Stripe refund event. ChargeId: {}, Refunded: {}, AmountRefunded: {}",
                    chargeId, charge.getRefunded(), charge.getAmountRefunded());

            // Try to get orderId from charge metadata or payment intent
            String orderId = null;
            if (charge.getMetadata() != null && charge.getMetadata().containsKey("orderId")) {
                orderId = charge.getMetadata().get("orderId");
            } else if (charge.getPaymentIntent() != null) {
                try {
                    PaymentIntent intent = PaymentIntent.retrieve(charge.getPaymentIntent());
                    orderId = intent.getMetadata().get("orderId");
                } catch (StripeException e) {
                    log.error("Error retrieving payment intent for refund: {}", e.getMessage(), e);
                }
            }

            if (orderId == null) {
                log.warn("Could not determine orderId for refund event. ChargeId: {}", chargeId);
                return null;
            }

            // Determine the appropriate status
            PaymentStatus status = charge.getRefunded() != null && charge.getRefunded()
                    ? PaymentStatus.REFUNDED
                    : PaymentStatus.PROCESSING;

            // Keep providerTransactionId pointing at the PaymentIntent so further refunds/queries keep working.
            String providerTransactionId = charge.getPaymentIntent();
            if (providerTransactionId == null || providerTransactionId.isBlank()) {
                providerTransactionId = chargeId;
            }

            log.info("Stripe refund processed. OrderId: {}, ChargeId: {}, Status: {}",
                    orderId, chargeId, refundStatus);

            return PaymentResponse.builder()
                    .status(status)
                    .orderId(UUID.fromString(orderId))
                    .paymentChannel(getProviderName())
                    .providerTransactionId(providerTransactionId)
                    .errorMessage("Refund " + refundStatus) // Use errorMessage to indicate refund status
                    .build();

        } catch (Exception e) {
            log.error("Error processing refund event: {}", e.getMessage(), e);
            return createErrorResponse("Error processing refund event: " + e.getMessage());
        }
    }

    private PaymentResponse createErrorResponse(String errorMessage) {
        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .paymentChannel(getProviderName())
                .errorMessage(errorMessage)
                .build();
    }
    
    private PaymentResponse handlePaymentError(PaymentRequest paymentRequest, StripeException e) {
        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .orderId(paymentRequest.getOrderId())
                .paymentChannel(getProviderName())
                .errorMessage(e.getMessage())
                .build();
    }

    @Override
    public String getProviderName() {
        return "STRIPE";
    }

    /**
     * Processes a refund for a Stripe payment.
     *
     * @param paymentIntentId the Stripe PaymentIntent ID
     * @param amount the amount to refund in the original currency (null for full refund)
     * @param reason the reason for the refund
     * @return refund response with refund details
     */
    public com.fusionxpay.payment.dto.RefundResponse processRefund(String paymentIntentId, BigDecimal amount, String reason) {
        log.info("Processing Stripe refund for PaymentIntent: {}", paymentIntentId);

        try {
            com.stripe.param.RefundCreateParams.Builder paramsBuilder = com.stripe.param.RefundCreateParams.builder()
                    .setPaymentIntent(paymentIntentId);

            // If amount is specified, it's a partial refund (convert to smallest unit)
            if (amount != null) {
                long amountInSmallestUnit = amount.multiply(new BigDecimal(100)).longValue();
                paramsBuilder.setAmount(amountInSmallestUnit);
            }

            // Set refund reason if provided
            if (reason != null && !reason.isEmpty()) {
                // Map to Stripe's predefined reasons
                com.stripe.param.RefundCreateParams.Reason stripeReason = mapRefundReason(reason);
                if (stripeReason != null) {
                    paramsBuilder.setReason(stripeReason);
                }
            }

            com.stripe.model.Refund refund = com.stripe.model.Refund.create(paramsBuilder.build());

            log.info("Stripe refund processed. PaymentIntentId: {}, RefundId: {}, Status: {}",
                    paymentIntentId, refund.getId(), refund.getStatus());

            return com.fusionxpay.payment.dto.RefundResponse.builder()
                    .refundId(UUID.randomUUID().toString())
                    .providerRefundId(refund.getId())
                    .status(mapStripeRefundStatus(refund.getStatus()))
                    .amount(amount != null ? amount : new BigDecimal(refund.getAmount()).divide(new BigDecimal(100)))
                    .currency(refund.getCurrency().toUpperCase())
                    .paymentChannel(getProviderName())
                    .createdAt(java.time.LocalDateTime.now())
                    .build();

        } catch (StripeException e) {
            log.error("Error processing Stripe refund for PaymentIntent {}: {}", paymentIntentId, e.getMessage(), e);
            return com.fusionxpay.payment.dto.RefundResponse.builder()
                    .status(com.fusionxpay.payment.model.RefundStatus.FAILED)
                    .paymentChannel(getProviderName())
                    .errorMessage("Stripe refund failed: " + e.getMessage())
                    .build();
        }
    }

    /**
     * Maps a string reason to Stripe's RefundCreateParams.Reason enum.
     */
    private com.stripe.param.RefundCreateParams.Reason mapRefundReason(String reason) {
        if (reason == null) {
            return null;
        }
        String lowerReason = reason.toLowerCase();
        if (lowerReason.contains("duplicate")) {
            return com.stripe.param.RefundCreateParams.Reason.DUPLICATE;
        } else if (lowerReason.contains("fraud")) {
            return com.stripe.param.RefundCreateParams.Reason.FRAUDULENT;
        } else if (lowerReason.contains("request") || lowerReason.contains("customer")) {
            return com.stripe.param.RefundCreateParams.Reason.REQUESTED_BY_CUSTOMER;
        }
        return null; // Use default if no match
    }

    /**
     * Maps Stripe refund status to internal RefundStatus.
     */
    private com.fusionxpay.payment.model.RefundStatus mapStripeRefundStatus(String stripeStatus) {
        if (stripeStatus == null) {
            return com.fusionxpay.payment.model.RefundStatus.PENDING;
        }
        switch (stripeStatus) {
            case "succeeded":
                return com.fusionxpay.payment.model.RefundStatus.COMPLETED;
            case "pending":
                return com.fusionxpay.payment.model.RefundStatus.PENDING;
            case "failed":
                return com.fusionxpay.payment.model.RefundStatus.FAILED;
            case "canceled":
                return com.fusionxpay.payment.model.RefundStatus.CANCELLED;
            default:
                return com.fusionxpay.payment.model.RefundStatus.PROCESSING;
        }
    }

    @Override
    public boolean validateCallback(String payload, String signature) {
        try {
            // Attempt to construct event to validate the signature
            Webhook.constructEvent(payload, signature, webhookSecret);
            return true;
        } catch (SignatureVerificationException e) {
            log.error("Invalid webhook signature: {}", e.getMessage(), e);
            return false;
        }
    }
}
