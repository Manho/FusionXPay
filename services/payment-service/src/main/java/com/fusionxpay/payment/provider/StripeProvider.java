package com.fusionxpay.payment.provider;

import com.fusionxpay.payment.dto.PaymentRequest;
import com.fusionxpay.payment.dto.PaymentResponse;
import com.fusionxpay.payment.service.IdempotencyService;
import com.fusionxpay.common.model.PaymentStatus;
import com.stripe.Stripe;
import com.stripe.exception.SignatureVerificationException;
import com.stripe.exception.StripeException;
import com.stripe.model.Event;
import com.stripe.model.PaymentIntent;
import com.stripe.model.checkout.Session;
import com.stripe.net.Webhook;
import com.stripe.param.checkout.SessionCreateParams;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Stripe payment processor implementation
 */
@Slf4j
@Service
public class StripeProvider implements PaymentProvider {

    @Value("${payment.providers.stripe.secret-key}")
    private String apiKey;

    @Value("${payment.providers.stripe.webhook-secret}")
    private String webhookSecret;
    
    // Redis configuration for idempotency
    private final RedisTemplate<String, String> redisTemplate;
    private final IdempotencyService idempotencyService;
    private static final String STRIPE_WEBHOOK_EVENT_PREFIX = "stripe:webhook:event:";
    private static final Duration EVENT_TTL = Duration.ofDays(7); // Store events for 7 days
    
    public StripeProvider(RedisTemplate<String, String> redisTemplate, IdempotencyService idempotencyService) {
        this.redisTemplate = redisTemplate;
        this.idempotencyService = idempotencyService;
    }

    @PostConstruct
    public void init() {
        Stripe.apiKey = apiKey;
        log.info("Stripe payment provider initialized");
    }

    @Override
    public PaymentResponse processPayment(PaymentRequest paymentRequest) {
        log.info("Processing payment with Stripe: {}", paymentRequest);

        try {
            // Create metadata for tracking
            Map<String, String> metadata = new HashMap<>();
            metadata.put("orderId", paymentRequest.getOrderId().toString());
            metadata.put("merchantReference", paymentRequest.getMerchantReference());

            // Create checkout session
            SessionCreateParams params = SessionCreateParams.builder()
                    .setMode(SessionCreateParams.Mode.PAYMENT)
                    .setSuccessUrl(paymentRequest.getReturnUrl())
                    .setCancelUrl(paymentRequest.getCancelUrl())
                    .addLineItem(createLineItem(paymentRequest))
                    .setPaymentIntentData(
                            SessionCreateParams.PaymentIntentData.builder()
                                    .putAllMetadata(metadata)
                                    .build()
                    )
                    .putAllMetadata(metadata)
                    .setClientReferenceId(paymentRequest.getOrderId().toString())
                    .build();

            Session session = Session.create(params);
            
            // Use session.getId() as Stripe's transaction reference
            // Our system's transaction ID will be generated by the database
            return PaymentResponse.builder()
                    .status(PaymentStatus.PROCESSING)
                    .orderId(paymentRequest.getOrderId())
                    .paymentChannel(getProviderName())
                    .redirectUrl(session.getUrl())
                    .providerTransactionId(session.getId()) // Store Stripe's session ID
                    .build();

        } catch (StripeException e) {
            log.error("Error processing Stripe payment: {}", e.getMessage(), e);
            return handlePaymentError(paymentRequest, e);
        }
    }

    private SessionCreateParams.LineItem createLineItem(PaymentRequest paymentRequest) {
        // Get amount in smallest currency unit (e.g. cents)
        long amountInSmallestUnit = paymentRequest.getAmount().multiply(new BigDecimal(100)).longValue();
        
        return SessionCreateParams.LineItem.builder()
                .setPriceData(
                        SessionCreateParams.LineItem.PriceData.builder()
                                .setCurrency(paymentRequest.getCurrency().toLowerCase())
                                .setUnitAmount(amountInSmallestUnit)
                                .setProductData(
                                        SessionCreateParams.LineItem.PriceData.ProductData.builder()
                                                .setName("Order #" + paymentRequest.getOrderId())
                                                .setDescription(paymentRequest.getDescription())
                                                .build()
                                )
                                .build()
                )
                .setQuantity(1L)
                .build();
    }

    @Override
    public PaymentResponse processCallback(String payload, String signature) {
        try {
            Event event = Webhook.constructEvent(payload, signature, webhookSecret);
            String eventId = event.getId();
            String eventType = event.getType();
            log.info("Processing Stripe webhook event: {}, id: {}", eventType, eventId);
            
            // Only process payment status events (success or failure)
            if (!isPaymentStatusEvent(eventType)) {
                log.info("Ignoring non-payment status event: {}", eventType);
                return null;
            }
            
            // Extract orderId based on event type
            String orderId;
            try {
                orderId = extractOrderIdFromEvent(event);
                if (orderId == null) {
                    log.warn("Could not extract orderId from event {}", eventId);
                    return createErrorResponse("Could not extract orderId from event");
                }
            } catch (Exception e) {
                log.error("Error extracting orderId from event: {}", e.getMessage(), e);
                return createErrorResponse("Error extracting orderId: " + e.getMessage());
            }
            
            // Create an order-based Redis key for idempotency
            String orderKey = STRIPE_WEBHOOK_EVENT_PREFIX + "order:" + orderId;
            
            // Check if this order's payment status has already been processed
            String processingState = idempotencyService.getProcessingState(orderKey);
            
            if (processingState != null) {
                if ("completed".equals(processingState)) {
                    log.info("Payment status for order {} already processed", orderId);
                    return PaymentResponse.builder()
                            .status(PaymentStatus.DUPLICATE)
                            .paymentChannel(getProviderName())
                            .providerTransactionId(eventId)
                            .orderId(UUID.fromString(orderId))
                            .build();
                } 
            }
            
            // Try to acquire processing lock for this order's payment status
            boolean lockAcquired = idempotencyService.acquireProcessingLock(orderKey, EVENT_TTL);
            
            if (!lockAcquired) {
                log.warn("Could not acquire processing lock for order {}", orderId);
                return PaymentResponse.builder()
                        .status(PaymentStatus.PROCESSING)
                        .paymentChannel(getProviderName())
                        .providerTransactionId(eventId)
                        .orderId(UUID.fromString(orderId))
                        .build();
            }
            
            // We acquired the lock, process the event
            PaymentResponse response = null;
            try {
                // Process the event based on type
                switch (eventType) {
                    case "payment_intent.succeeded":
                        response = handlePaymentSuccess(event);
                        break;
                    case "payment_intent.payment_failed":
                        response = handlePaymentFailure(event);
                        break;
                    case "checkout.session.completed":
                        response = handleCheckoutSessionCompleted(event);
                        break;
                    default:
                        log.info("Unhandled event type: {}", eventType);
                        response = null;
                        break;
                }
                
                // Mark as successfully completed if appropriate
                if (response != null && response.getStatus() != PaymentStatus.FAILED) {
                    idempotencyService.markAsCompleted(orderKey, EVENT_TTL);
                } else if (response == null) {
                    // For events we don't care about, release the lock
                    idempotencyService.releaseLock(orderKey);
                } else {
                    // For failed responses, mark as completed to prevent retries
                    // (we still consider a failed payment as "completed" processing)
                    idempotencyService.markAsCompleted(orderKey, EVENT_TTL);
                }
                
                return response;
            } catch (Exception e) {
                // On any exception, release the lock
                idempotencyService.releaseLock(orderKey);
                throw e;
            }
        } catch (SignatureVerificationException e) {
            log.error("Invalid webhook signature: {}", e.getMessage(), e);
            return createErrorResponse("Invalid webhook signature");
        } catch (Exception e) {
            log.error("Error processing webhook: {}", e.getMessage(), e);
            return createErrorResponse("Webhook processing error: " + e.getMessage());
        }
    }

    // Helper method to determine if this event affects payment status
    private boolean isPaymentStatusEvent(String eventType) {
        return eventType.equals("payment_intent.succeeded") || 
               eventType.equals("payment_intent.payment_failed") ||
               eventType.equals("checkout.session.completed");
    }

    // Helper method to extract orderId from different event types
    private String extractOrderIdFromEvent(Event event) {
        String eventType = event.getType();
        if (eventType.equals("payment_intent.succeeded") || eventType.equals("payment_intent.payment_failed")) {
            PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
            return intent.getMetadata().get("orderId");
        } else if (eventType.equals("checkout.session.completed")) {
            Session session = (Session) event.getDataObjectDeserializer().getObject().get();
            if (session.getPaymentIntent() != null) {
                try {
                    PaymentIntent intent = PaymentIntent.retrieve(session.getPaymentIntent());
                    return intent.getMetadata().get("orderId");
                } catch (StripeException e) {
                    log.error("Error retrieving payment intent: {}", e.getMessage(), e);
                    return null;
                }
            } else {
                return session.getClientReferenceId(); // Fallback to client reference ID which should be orderId
            }
        }
        return null;
    }

    // Helper method to handle checkout.session.completed events
    private PaymentResponse handleCheckoutSessionCompleted(Event event) {
        Session session = (Session) event.getDataObjectDeserializer().getObject().get();
        if (session.getPaymentIntent() != null) {
            try {
                PaymentIntent intent = PaymentIntent.retrieve(session.getPaymentIntent());
                String orderId = intent.getMetadata().get("orderId");
                
                return PaymentResponse.builder()
                        .status(PaymentStatus.SUCCESS)
                        .orderId(UUID.fromString(orderId))
                        .paymentChannel(getProviderName())
                        .providerTransactionId(session.getId())
                        .build();
            } catch (StripeException e) {
                log.error("Error retrieving payment intent: {}", e.getMessage(), e);
                return createErrorResponse("Error retrieving payment intent: " + e.getMessage());
            }
        } else {
            log.info("Checkout session completed without PaymentIntent");
            return null;
        }
    }

    private PaymentResponse handlePaymentSuccess(Event event) {
        PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
        log.info("Payment succeeded for intent: {}", intent.getId());
        
        String orderId = intent.getMetadata().get("orderId");
        
        return PaymentResponse.builder()
                .status(PaymentStatus.SUCCESS)
                .orderId(UUID.fromString(orderId))
                .paymentChannel(getProviderName())
                .providerTransactionId(intent.getId()) // Store Stripe's payment intent ID
                .build();
    }

    private PaymentResponse handlePaymentFailure(Event event) {
        PaymentIntent intent = (PaymentIntent) event.getDataObjectDeserializer().getObject().get();
        log.info("Payment failed for intent: {}", intent.getId());
        
        String orderId = intent.getMetadata().get("orderId");
        String errorMessage = intent.getLastPaymentError() != null ? 
                intent.getLastPaymentError().getMessage() : "Payment failed";
                
        log.error("Payment failed: {}, order: {}", errorMessage, orderId);
        
        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .orderId(UUID.fromString(orderId))
                .paymentChannel(getProviderName())
                .providerTransactionId(intent.getId()) // Store Stripe's payment intent ID
                .errorMessage(errorMessage)
                .build();
    }

    private PaymentResponse createErrorResponse(String errorMessage) {
        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .paymentChannel(getProviderName())
                .errorMessage(errorMessage)
                .build();
    }
    
    private PaymentResponse handlePaymentError(PaymentRequest paymentRequest, StripeException e) {
        return PaymentResponse.builder()
                .status(PaymentStatus.FAILED)
                .orderId(paymentRequest.getOrderId())
                .paymentChannel(getProviderName())
                .errorMessage(e.getMessage())
                .build();
    }

    @Override
    public String getProviderName() {
        return "STRIPE";
    }
    
    @Override
    public boolean validateCallback(String payload, String signature) {
        try {
            // Attempt to construct event to validate the signature
            Webhook.constructEvent(payload, signature, webhookSecret);
            return true;
        } catch (SignatureVerificationException e) {
            log.error("Invalid webhook signature: {}", e.getMessage(), e);
            return false;
        }
    }
}